#2.1 vanillaJs 와 ReactJS의 차이를 비교해보자

VanillaJS에서는
STEP1 HTML만든다
STEP2html element 찾아 js에 가져오기
STEP3 : event 감지하기
STEP4 JS 변수 데이터 업데이트
STEP5 HTML에 변경점 업데이트
과정을 거친다
단순하면 당연히 문제 없겠지만,
점점 복잡해질수록 handle 지옥에서 벗어나기 힘들다.


ReactJS를 수행하기 위해서는
가장 먼저 React와 React-DOM 라이브러리르 가져와야 한다.

<!DOCTYPE html>
<html>
    <body></body>
    <script src="https://unpkg.com/react@17.0.2/umd/react.production.min.js"> </script>
    <script src="https://unpkg.com/react-dom@17.0.2/umd/react-dom.production.min.js"> </script>
</html>

아래와 같은 방법으로 리액트를 불러온다.
console에서 React를 찍었을 때 출력이 되면 무사히 완성한 것임.

ReactJS의 규칙 중 하나는 HTML을 HTML 페이지에 직접 작성하지 않는다는 점이다.
모두다 js 파일에 react JS로 쓴다.

이번에는 reacjs로 element를 생성하는 매우 귀찮고 복잡한 방법을 시현한다.
어려운 방식을 살펴보면서 ReactJS의 본질을 이해할 수 있다.

React.createElement("",{}, )
1번째 변수 element name(div, span, button 등등...), 
2번째 변수 property(classname id ....),
3번째 변수 안에 들어갈 내용

ReactJS는 application이 아주 interactive하도록 만들어주는 library이고,
ReactJSDOM은  모든 React element들을 html body에 둘 수 있도록 해준다.

요컨데 핵심은
vanilla에서는 HTML을 만들고 -> JS에 가져와서 -> HTML을 수정하는 방식이었지만
ReactJS에서는 모든것이 JS로 시작한 후 html이 되는것 (생성, 수정, 업데이트 등등) 
생성, 수정, 렌더링도 모두 ReactJS에서 이루어지기에 
업데이트 해야하는 HTML을 업데이트 하도록 JS 쪽에서 컨트롤 할 수 있다는 점이 중요

#2.3


React.createElement("",{}, )의 두번째 변수에
classname id와 같은 property가 들어가기도 하지만
eventlistener도 들어갈 수 있다!! onClick: () => {} 함수로.

vanilla JS에서는
    <button id="btn"> Click me</button> <!--STEP1 HTML만든다-->
    const button = document.querySelector("#btn"); //STEP2html element 찾아 js에 가져오기
    function handleClick(){span.innerText = `Total Clicks : ${counter}`; }
    button.addEventListener("click",handleClick)
이렇게 네줄이 필요하던 것이

ReactJS에서는
const btn = React.createElement("button", {onclick: () => console.log("i am clicked")}, "Click Me!");
이 한줄로 해결이 된다!

#2.5 
JSX 
JSX는 JavaScript를 확장한 문법이다
기본적으로 우리가 한 것처럼 React 요소를 만들 수 있게 해주는데
HTML에서 사용하는 문법과 흡사한 문법을 사용해서  

Babel 은 쉬운버전 JSX를 컴퓨터가 이해할 수 있도록 JS(하드모드)로 번역시켜주는 라이브러리

결국 JSX 문법은 사람이 더 쉽게 작성하기 위해 쓰이는 거지
결국 JSX 로 작성한 코드는 babel을 통해 다시 JS 문법 ~ Reactjs 하드모드 문법으로 번역한 다음
ReactJS / ReactJSDOM 으로 렌더링 하는거다.

JSX – 자바스크립트를 확장한 문법
보통의 HTML과 비슷. 그러나 property를 HTML 태그의 속성처럼 적으면 됨
const Title = (
console.log("mouse enter")}>
Hello I'm a span
);
style={{ backgroundColor: "tomato" }} -> 스타일은 {} 2개임
JSX를 브라우저가 온전히 이해하지 못하므로 이해할 수 있게
https://unpkg.com/@babel/standalone/babel.min.js 를 설치해야함
-> JSX로 적은 코드를 브라우저가 이해할 수 있는 형태로 바꿔줌
바벨을 가져온 뒤 script type="text/babel"로 적어줘야 인식함



#2.6 
액션까지 낭낭하게 넣어둔 element를 rendering 하기 위해서 
 ReactJS 하드모드에서는 
 const container = React.createElement("div", null, [h3, btn]);
 를 썼다.

 const container = <div> h3 btn </div>
 그냥 이렇게만 하면 "h3 btn" 이라는 글자만 출력될 뿐이다.

 그냥 텍스트가 아니라 요인을 집어넣고 싶으면
 요인이 그냥 Object가 아닌
    const h3 = (
      <h3 id="h3" onMouseEnter={() => console.log("mouse Entered")}>
        Hello, i am a h3
      </h3>
    );

함수형으로 정의해야 한다.
arrowfunction으로 아래처럼 하던가
    const h3 = () => (
      <h3 id="h3" onMouseEnter={() => console.log("mouse Entered")}>
        Hello, i am a h3
      </h3>
    );

그냥 일반 함수 정의로 아래처럼 해야한다.
    function h3() {
            return(
        <h3 id="h3" onMouseEnter={() => console.log("mouse Entered")}>
            Hello, i am a h3
        </h3>
        );
    }

element들을 함수화 했다면, 
 const container = <div> H3 Btn </div>
 를
 const Contianer = <div> <H3 /> <Btn /> </div>
로 작성한다.

※ 주의점 
JSX에서 함수형으로 정의된 element는 첫글자 대문자로 정의내려라
그렇지 않으면, <Button /> 이 아닌 <button /> 로 작성하면
우리가 정의내린 element인지, 아니면 html 기본 element를 가져다 쓴건지 구별을 못한다.

#3.0

state = 바뀌는 데이터를 저장하는 곳

vanillaJS에서 한번 클릭할 때마다 카운트가 올라가는 기능 ~ state로 구현한다.

※변수를 JSX에 전달하는 방법

JS에서는 .innerText = ~~~ 를 써서 \
span.innerText = `Total Clicks : ${counter}` 
와 같은 방식으로 반영했다면,

JSX에서는  <element > ~~~~ {변수} </element>  element 사이에 입력하고 싶은 변수를 중괄호에 감싸줌으로써

let counter = 0;

<div>
    <h3> Total Click : {counter} </h3>
    <button> Click Me!</button>
</div>
와 가은 방식으로 반영한다.

※ 중요한 사실은, 아무리 eventlistner를 element에 달아두고, 변수가 함수에 의해 변화하더라도
바뀐 값들이 제때 제때 리렌더링 되지 않으면, 화면에서는 그 변화가 반영되지 않는다.
즉, 액션을 취할때마다 렌더링 과정을 거쳐준다.


React의 강점은 현재 시점에서 vanilla와 Reactjs 결과값을 실행했을 때
countup 버튼을 클릭할 때마다 Devtool에서 값을 업데이트하는 범위를 보면서 알 수있다.

vanilla는 연관되어 있는 모든 element를 다 업데이트 하는 반면에
reactjs는 변환하는 counter 변수 값 하나만 업데이트 되는 것을 확인할 수 있다.
button / title/ h3 등 변화하지 않는것을 모두 새로고침할 필요 없이 바뀐 부분만 업데이트 해주는 것은
엄청난 양의 연산 낭비를 막아준다.

1. element에 변수를 넣고 싶으면 {변수} 만 추가하면 끝.
2. 바뀐 값에 따라 ui를 업데이트 하고 싶으면 ReactDOM.render() 함수를 사용하면 된다
3. ReactDOM.render() 로 업데이트 하더라도, 전체를 새로 다 불러오는 것이 아닌, 바뀐 부분만 찾아서 업데이트 해준다.

BUT... 매번 함수로 변수 값이 바뀔때마다 ReactDOM.render() 함수를 추가하는 것은 비효율이다.


const data = React.useState( defaultValue ); 
로 정의한 data를 열어보면
[defaultValue, f] 를 가진 array임을 알 수 있다.
앞부분은 우리가 다룰 데이터가 들어가고
뒷부부은 관련된 함수로 구성되어 있음

즉 
const data = React.useState( defaultValue ) 꼴은
와

let counter = 0;
function counterUp(){
    //code
}
는 같은 의미를 가진다.

※ array 속에 있는 것들을 불러오는 방법
1) 기존의 방법
const food = ["tomato", "potato"]
const favFood = food[0];
const terFood = food[1];

2) 더 깔끔한 방법
const food = ["tomato", "potato"]
const [favFood, terFood] = food;

3) 더더 깔끔한 방법 
const [favFood, terFood] = ["tomato", "potato"]

#3.2 

왜 react.useState 속 modifier가 필요할까?
 3.0에서 겪었듯이, 함수로 아무리 value를 변화해도
 함수 끝마다 ReactDOM.render() 해주지 않으면 화면에 변화가 반영되지 않는다. ~ 매번 같은 코드를 반복하는건 비효율!

 modifier는 어떤 값을 부여하던 그 갚으로 업데이트 하고 리렌더링을 해준다.

 [state, setState] = React.useState( 기본값);

    const action = () => {
    setState(state + 1);
    }; //setState 에다 원하는 함수 output을 넣으면, 업데이트되고, 리렌더링까지 해준다.

    return (
    <div>
        <h3> Total Click : {state} </h3>
        <button onClick={action}> Click Me!</button>
    </div>
    ); // 화면에 출력할 친구들
}
ReactDOM.render(<App />, root);

구조를 가지면 된다.

modifier 함수로 state가 바뀔때, 
해당하는 app() 함수 코드 전체가 가동되고
return 안에 있는 컴포넌트 전체도 재생성 된다 (새로 업데이트된 값과 함께)
그 와중에 똑똑하게, 바뀐 부분만 다시 만든다.

React.useState() 배열에서
보통 데이터에는 counter처럼 원하는대로 붙이고
f는 set 뒤에 데이터 이름을 붙임 (setCounter)
어떤값을 부여하던 setCounter 함수는 그 값으로 업데이트하고 리렌더링 일으킴
1. counter라는 데이터를 받음
2. return()에 그 데이터를 담고 있음 (리턴은 사용자가 보게될 컴포넌트)
3. 버튼이 클릭되면 counter값을 바꿔줄 함수 호출 -> setCounter
4. counter의 새로운 값을 가지고 counter 함수를 호출
5. 그 새로운 값은 setCounter(counter + 1)에 써준 counter + 1


#3.4

const [x, setX] = React.useState();
에서 
setX( x ~~~~) ; 이런 식은 권장하지 않는다.
왜냐면 x가 다른 곳에서 update 될 수도 있기 때문
어쩌면 x가 다른 곳에서 변경되어서 우리가 생각하는 값이 아닐 수도 있다 ☆☆☆☆
단순한 구조에서는 이러한 오류를 시현하기 어렵지만



state를 바꾸는 2가지 방법이 있다
방법1) setX( 15 ) setX를 이용해서 우리가 원하는 값(숫자 / 문자 등등)을 넣어주는 것.
방법2) setX( x ~) 이전 값을 이용해서 현재 값을 계산해내는 방법


setCounter(counter + 1);
함수의 꼴로 넣어주는게 더 적합하다
여기서 함수형으로 만들어두면, 변수는 무조건 최근에 업데이트된 변수(본 예시에서는 counter)를 넣어준다.
setCounter((current) => current + 1); // 이 방식이 더올바른 방식이다. 
setCounter 안에 정의된 함수에서 인자는 무조건 counter이다. ★★★★
