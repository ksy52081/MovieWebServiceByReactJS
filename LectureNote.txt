#2.1 vanillaJs 와 ReactJS의 차이를 비교해보자

VanillaJS에서는
STEP1 HTML만든다
STEP2html element 찾아 js에 가져오기
STEP3 : event 감지하기
STEP4 JS 변수 데이터 업데이트
STEP5 HTML에 변경점 업데이트
과정을 거친다
단순하면 당연히 문제 없겠지만,
점점 복잡해질수록 handle 지옥에서 벗어나기 힘들다.


ReactJS를 수행하기 위해서는
가장 먼저 React와 React-DOM 라이브러리르 가져와야 한다.

<!DOCTYPE html>
<html>
    <body></body>
    <script src="https://unpkg.com/react@17.0.2/umd/react.production.min.js"> </script>
    <script src="https://unpkg.com/react-dom@17.0.2/umd/react-dom.production.min.js"> </script>
</html>

아래와 같은 방법으로 리액트를 불러온다.
console에서 React를 찍었을 때 출력이 되면 무사히 완성한 것임.

ReactJS의 규칙 중 하나는 HTML을 HTML 페이지에 직접 작성하지 않는다는 점이다.
모두다 js 파일에 react JS로 쓴다.

이번에는 reacjs로 element를 생성하는 매우 귀찮고 복잡한 방법을 시현한다.
어려운 방식을 살펴보면서 ReactJS의 본질을 이해할 수 있다.

React.createElement("",{}, )
1번째 변수 element name(div, span, button 등등...), 
2번째 변수 property(classname id ....),
3번째 변수 안에 들어갈 내용

ReactJS는 application이 아주 interactive하도록 만들어주는 library이고,
ReactJSDOM은  모든 React element들을 html body에 둘 수 있도록 해준다.

요컨데 핵심은
vanilla에서는 HTML을 만들고 -> JS에 가져와서 -> HTML을 수정하는 방식이었지만
ReactJS에서는 모든것이 JS로 시작한 후 html이 되는것 (생성, 수정, 업데이트 등등) 
생성, 수정, 렌더링도 모두 ReactJS에서 이루어지기에 
업데이트 해야하는 HTML을 업데이트 하도록 JS 쪽에서 컨트롤 할 수 있다는 점이 중요

#2.3


React.createElement("",{}, )의 두번째 변수에
classname id와 같은 property가 들어가기도 하지만
eventlistener도 들어갈 수 있다!! onClick: () => {} 함수로.

vanilla JS에서는
    <button id="btn"> Click me</button> <!--STEP1 HTML만든다-->
    const button = document.querySelector("#btn"); //STEP2html element 찾아 js에 가져오기
    function handleClick(){span.innerText = `Total Clicks : ${counter}`; }
    button.addEventListener("click",handleClick)
이렇게 네줄이 필요하던 것이

ReactJS에서는
const btn = React.createElement("button", {onclick: () => console.log("i am clicked")}, "Click Me!");
이 한줄로 해결이 된다!

#2.5 
JSX 
JSX는 JavaScript를 확장한 문법이다
기본적으로 우리가 한 것처럼 React 요소를 만들 수 있게 해주는데
HTML에서 사용하는 문법과 흡사한 문법을 사용해서  

Babel 은 쉬운버전 JSX를 컴퓨터가 이해할 수 있도록 JS(하드모드)로 번역시켜주는 라이브러리

결국 JSX 문법은 사람이 더 쉽게 작성하기 위해 쓰이는 거지
결국 JSX 로 작성한 코드는 babel을 통해 다시 JS 문법 ~ Reactjs 하드모드 문법으로 번역한 다음
ReactJS / ReactJSDOM 으로 렌더링 하는거다.

JSX – 자바스크립트를 확장한 문법
보통의 HTML과 비슷. 그러나 property를 HTML 태그의 속성처럼 적으면 됨
const Title = (
console.log("mouse enter")}>
Hello I'm a span
);
style={{ backgroundColor: "tomato" }} -> 스타일은 {} 2개임
JSX를 브라우저가 온전히 이해하지 못하므로 이해할 수 있게
https://unpkg.com/@babel/standalone/babel.min.js 를 설치해야함
-> JSX로 적은 코드를 브라우저가 이해할 수 있는 형태로 바꿔줌
바벨을 가져온 뒤 script type="text/babel"로 적어줘야 인식함



#2.6 
액션까지 낭낭하게 넣어둔 element를 rendering 하기 위해서 
 ReactJS 하드모드에서는 
 const container = React.createElement("div", null, [h3, btn]);
 를 썼다.

 const container = <div> h3 btn </div>
 그냥 이렇게만 하면 "h3 btn" 이라는 글자만 출력될 뿐이다.

 그냥 텍스트가 아니라 요인을 집어넣고 싶으면
 요인이 그냥 Object가 아닌
    const h3 = (
      <h3 id="h3" onMouseEnter={() => console.log("mouse Entered")}>
        Hello, i am a h3
      </h3>
    );

함수형으로 정의해야 한다.
arrowfunction으로 아래처럼 하던가
    const h3 = () => (
      <h3 id="h3" onMouseEnter={() => console.log("mouse Entered")}>
        Hello, i am a h3
      </h3>
    );

그냥 일반 함수 정의로 아래처럼 해야한다.
    function h3() {
            return(
        <h3 id="h3" onMouseEnter={() => console.log("mouse Entered")}>
            Hello, i am a h3
        </h3>
        );
    }

element들을 함수화 했다면, 
 const container = <div> H3 Btn </div>
 를
 const Contianer = <div> <H3 /> <Btn /> </div>
로 작성한다.

※ 주의점 
JSX에서 함수형으로 정의된 element는 첫글자 대문자로 정의내려라
그렇지 않으면, <Button /> 이 아닌 <button /> 로 작성하면
우리가 정의내린 element인지, 아니면 html 기본 element를 가져다 쓴건지 구별을 못한다.

#3.0

state = 바뀌는 데이터를 저장하는 곳

vanillaJS에서 한번 클릭할 때마다 카운트가 올라가는 기능 ~ state로 구현한다.

※변수를 JSX에 전달하는 방법

JS에서는 .innerText = ~~~ 를 써서 \
span.innerText = `Total Clicks : ${counter}` 
와 같은 방식으로 반영했다면,

JSX에서는  <element > ~~~~ {변수} </element>  element 사이에 입력하고 싶은 변수를 중괄호에 감싸줌으로써

let counter = 0;

<div>
    <h3> Total Click : {counter} </h3>
    <button> Click Me!</button>
</div>
와 가은 방식으로 반영한다.

※ 중요한 사실은, 아무리 eventlistner를 element에 달아두고, 변수가 함수에 의해 변화하더라도
바뀐 값들이 제때 제때 리렌더링 되지 않으면, 화면에서는 그 변화가 반영되지 않는다.
즉, 액션을 취할때마다 렌더링 과정을 거쳐준다.


React의 강점은 현재 시점에서 vanilla와 Reactjs 결과값을 실행했을 때
countup 버튼을 클릭할 때마다 Devtool에서 값을 업데이트하는 범위를 보면서 알 수있다.

vanilla는 연관되어 있는 모든 element를 다 업데이트 하는 반면에
reactjs는 변환하는 counter 변수 값 하나만 업데이트 되는 것을 확인할 수 있다.
button / title/ h3 등 변화하지 않는것을 모두 새로고침할 필요 없이 바뀐 부분만 업데이트 해주는 것은
엄청난 양의 연산 낭비를 막아준다.

1. element에 변수를 넣고 싶으면 {변수} 만 추가하면 끝.
2. 바뀐 값에 따라 ui를 업데이트 하고 싶으면 ReactDOM.render() 함수를 사용하면 된다
3. ReactDOM.render() 로 업데이트 하더라도, 전체를 새로 다 불러오는 것이 아닌, 바뀐 부분만 찾아서 업데이트 해준다.

BUT... 매번 함수로 변수 값이 바뀔때마다 ReactDOM.render() 함수를 추가하는 것은 비효율이다.


const data = React.useState( defaultValue ); 
로 정의한 data를 열어보면
[defaultValue, f] 를 가진 array임을 알 수 있다.
앞부분은 우리가 다룰 데이터가 들어가고
뒷부부은 관련된 함수로 구성되어 있음

즉 
const data = React.useState( defaultValue ) 꼴은
와

let counter = 0;
function counterUp(){
    //code
}
는 같은 의미를 가진다.

※ array 속에 있는 것들을 불러오는 방법
1) 기존의 방법
const food = ["tomato", "potato"]
const favFood = food[0];
const terFood = food[1];

2) 더 깔끔한 방법
const food = ["tomato", "potato"]
const [favFood, terFood] = food;

3) 더더 깔끔한 방법 
const [favFood, terFood] = ["tomato", "potato"]

#3.2 

왜 react.useState 속 modifier가 필요할까?
 3.0에서 겪었듯이, 함수로 아무리 value를 변화해도
 함수 끝마다 ReactDOM.render() 해주지 않으면 화면에 변화가 반영되지 않는다. ~ 매번 같은 코드를 반복하는건 비효율!

 modifier는 어떤 값을 부여하던 그 갚으로 업데이트 하고 리렌더링을 해준다.

 [state, setState] = React.useState( 기본값);

    const action = () => {
    setState(state + 1);
    }; //setState 에다 원하는 함수 output을 넣으면, 업데이트되고, 리렌더링까지 해준다.

    return (
    <div>
        <h3> Total Click : {state} </h3>
        <button onClick={action}> Click Me!</button>
    </div>
    ); // 화면에 출력할 친구들
}
ReactDOM.render(<App />, root);

구조를 가지면 된다.

modifier 함수로 state가 바뀔때, 
해당하는 app() 함수 코드 전체가 가동되고
return 안에 있는 컴포넌트 전체도 재생성 된다 (새로 업데이트된 값과 함께)
그 와중에 똑똑하게, 바뀐 부분만 다시 만든다.

React.useState() 배열에서
보통 데이터에는 counter처럼 원하는대로 붙이고
f는 set 뒤에 데이터 이름을 붙임 (setCounter)
어떤값을 부여하던 setCounter 함수는 그 값으로 업데이트하고 리렌더링 일으킴
1. counter라는 데이터를 받음
2. return()에 그 데이터를 담고 있음 (리턴은 사용자가 보게될 컴포넌트)
3. 버튼이 클릭되면 counter값을 바꿔줄 함수 호출 -> setCounter
4. counter의 새로운 값을 가지고 counter 함수를 호출
5. 그 새로운 값은 setCounter(counter + 1)에 써준 counter + 1


#3.4

const [x, setX] = React.useState();
에서 
setX( x ~~~~) ; 이런 식은 권장하지 않는다.
왜냐면 x가 다른 곳에서 update 될 수도 있기 때문
어쩌면 x가 다른 곳에서 변경되어서 우리가 생각하는 값이 아닐 수도 있다 ☆☆☆☆
단순한 구조에서는 이러한 오류를 시현하기 어렵지만


state를 세팅하는 데는 2가지 방법이 있다.
방법1) 직접 할당 :setState(state +1)
    setX( 15 ) setX를 이용해서 우리가 원하는 값(숫자 / 문자 등등)을 넣어주는 것.
방법2)함수를 할당:setState(state => state +1) (함수의 첫번째 인자는 현재 state 이다)
    setX( x ~) 이전 값을 이용해서 현재 값을 계산해내는 방법

현재 state랑 관련이 없는 값을 새로운 state로 하고싶은 경우에는 (방법1),
현재 state에 조금의 변화를 주어서 새로운 state를 주고 싶은 경우에는 (방법2)


setCounter(counter + 1);
함수의 꼴로 넣어주는게 더 적합하다
여기서 함수형으로 만들어두면, 변수는 무조건 최근에 업데이트된 변수(본 예시에서는 counter)를 넣어준다.
setCounter((current) => current + 1); // 이 방식이 더올바른 방식이다. 
setCounter 안에 정의된 함수에서 인자는 무조건 counter이다. ★★★★

???왜 setState에 current라고 넣어줘도 작동하는건가요?
setState는 함수이고, 인자값으로 객체를 넣어주면 알아서 현재 state값을 찾아 매핑되는건가요?

맞습니다. setState의 인자값이 객체인지 함수인지 판별하는 부분이 있습니다. \
함수일 경우 저장되어 있는 값(객체)을 인자로하여 리턴한 값을 최종적으로 업데이트 합니다. 
확인하시고 싶으시면 react-dom.development.js 15228 번째 라인입니다.(v17.0.2)


setCounter()에 값으로 넣을지 함수로 넣어줄지가 헷갈리신다면,
onClick 함수안에 여러번 넣어서 테스트해보시면 이해가 빠를 것 같습니다.

1. 값으로 여러번
function onClick() {
setCounter(counter + 1);
setCounter(counter + 1);
setCounter(counter + 1);
setCounter(counter + 1);
setCounter(counter + 1);
}
2. 함수로 여러번
function onClick() {
setCounter(current => current+ 1);
setCounter(current => current+ 1);
setCounter(current => current+ 1);
setCounter(current => current+ 1);
setCounter(current => current+ 1);
}
1번으로 돌렸을 경우에는 setCounter를 몇번을 호출해도 한 번만 실행되는 걸 보실 수 있고(counter가 1만 증가)
2번으로 돌렸을 경우에는 setCounter가 호출된 만큼 counter가 증가된 걸 볼 수 있습니다.

한 번 연습해보시고 니코쌤 설명을 들으면 이해가 더 될거라 생각합니다.


setCounter((firstargument)=> firstargument +1));
firstargument에 자동으로 현재 state값을 호출해서
return을 그값에다가 +1해준것입니다.
fistargument는 단순한 변수명이고, ( ) 안에 ,로 구분된 몇번째 인자에
어떤 특성값이 자동으로 할당된다라는 설명이 동영상내에 있으니
참조하시면 될 것 같습니다.

#3.5 
unit convert application 시간-분 원-달러

<label> = input 옆에 써주는 글씨 ~ 누군가 이글씨를 누르면 그 옆 input이선택됨
<label for = {연결할 id}
<label htmlFor = {연결할 id}

react, reactdom을 import하는 script tag에서
  <script src="https://unpkg.com/react@17.0.2/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@17.0.2/umd/react-dom.production.min.js"></script>
production - > development 로 변경하는데
  <script src="https://unpkg.com/react@17.0.2/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@17.0.2/umd/react-dom.development.js"></script>
production은 배포 모드, development는 개발 모드를 의미합니다.
개발모드는 니코쌤이 보여준 것 처럼 버그로 이어질 수 있는 요소들을 미리 경고하는 검증 코드가 포함되어 있습니다.

하.지.만 JSX는 html과 다르다.
html에서는 for, class 같은 단어가 문제가 없지만
JS. JSX 와 같은데서는 혼란을 줄 여지가 매우 크다.

class 대신 className을 쓰며
for 대신 htmlFor 를 써야 한다.


※react 세상에선 
우리가 직접 입력하는 값들을 uncontrolled value 라고 부른다.

글자를 쓸 때마다 input 속에 들어가 있는 값들을 minutes 에 반영하고 싶을때






#3.6

input 과 value를 이어주면
value의 값을 input에도 반영되고
input값을 외부에서도 수정이 가능하게 된다

Value 안에는 
value = {minutes}
state만 정갈하게 들어가는 것 뿐만 아니라

value={Math.round(minutes/60)}
처럼 입맛대로 변형해서 넣을 수도 있다.

minutes -> hours 의 경우에는
minutes를 넣는 input 엘레먼트 안에 onChange={onChange} 와 같이
이벤트 리더가 있고 
이벤트 리더 안에 setMinutes(event.target.value); 로 업데이트/리렌더링도 구현되어 있지만

hours -> minutes 의 경우에는
어떠한 이벤트 리더도, state, setState 함수도 정의된 바가 없다.


Q1
마지막 리셋버튼의 핸들러 함수의 표기법이 의아해서 질문합니다.
const reset = () => setMinutes(0); 이렇게 작성해 주셨는데, 이렇게 해도 되는거 보니 함수 표기법상 가능한 거겠죠? 화살표 함수는 알고 있는데 {}가 나올 바디 부분에 modifier함수가 있으니 매우 생소합니다.
고수님들의 설명 한번 부탁드립니다.

A1
arrow 쓸 때 한 줄로만 나타낼 수 있으면 {} 생략할 수 있습니다.
앞 선 강의에서도 나왔겠지만 함수 내용이 여러 줄일 경우 {}로 묶어주고
리턴되는 내용은 ()로 묶어서 나타낼 수 있습니다.


#3.7

fliped 변수 = boolean이다.

id = "hours"인 <input> 은 disabled = {true}가 기본값이다.
즉, fliped가 false 일때 disabled = true가 되어야 한다.
true = {fliped === false} 면 해결




flip
const onFlip = () => setFlipped(!flipped);
-> flipped가 true라면 부정명제인 !flipped는 false
-> false라면 true

state값으로 input을 enabled할지 disabled 할지를 결정할 수 있음

디폴트 값이 false 라고 정했으므로 Hours는 disabled 되어야함
그래서 disabled={flipped === false}를 써줘서
flipped가 false라면, disabled는 true가 되도록 만들어줌
Minuets에는 반대로
disabled={flipped === true}라고 써줌
그러나
Hours는
disabled={!flipped}
Minuets에는 반대로
disabled={flipped}
주는게 더 짧고 좋음

시간 -> 분 컨버터
삼항연산자(ternary operator) 사용하기
flipped ? amount : amount / 60
-> 만약 flipped 상태면 state에 있는 값을 그대로 보여주기
아니라면 60으로 나눈 변환된 값 보여주기
value={flipped ? amount * 60 : amount}
-> 만약 flipped 상태면 60으로 곱한 변환된 값 보여주기
아니라면 state에 있는 값을 그대로 보여주기

flip누르면 변화된 값 그대로 가져오므로
onFlip 변수에 reset(); 넣어주기


문제는~~ 내가 hours input에 뭐라고 써넣든
value는 항상 math.round(minutes/60) 을 따라갈 것이다.
이것은 우리가 원하는 방향이 아니다
내강 원하는 건 변환없이 내가 쓴 value를 그대로 보여주고 싶은 것이다.

math.round(minutes/60)의 변환 공식의 적용은
내가 minutes input에 썼을 때만 일어나야만 한다.

여기에 이미 우리는 
변환공식{math.round(minutes/60)}과
스위치 조건 (fliped)를
모두 가지고 있다

여기서 우리는 삼항연산자(ternary operator)로 바꿔주겠다
인라인 if문이라고 보면 된다
{조건문 ? 참일경우 : 거짓일경우}
로 구성된다.

헷갈리니까 minute, setMinutes는 
amount, setAmount로 변형하자.

#3.9

<select> 컴포넌트

<select>
    <option> Min & Hours </option> 
    <option> KM & Miles </option> 
</select>



중괄호 {}를 쓰면 js 스크립트를 넣을 수 있다!

속성으로 value 를 가질 수 있으면 onChange 속성을 붙일 수 있다.
SELECT, OPTION에도 붙힐 수 있다 (드롭다운) 11:12 참고하자

useState의 두번째 인자인 modifier함수를 실행하면 해당 컴포넌트가 리렌더링 된다.

[리렌더링 조건]
1) props이 바뀔때
2) state가 바뀔때
3) 부모 컴포넌트가 리렌더링 될 때


#4.0 props이
props는 일종의 방식
부모 컴포넌트로부터 자식컴포넌트에게 데이터를 보낼 수 있게 해주는 방법

생성한 예시에서
부모 컴포넌트는 <App />
자식 컴포넌트는 <MinutesToHours /> <KmToMiles />

App은 자식보다 훨씬 작을 뿐만 아니라
자식들은 부모컴포넌트의 데이터를 필요로 하지 않는다. (독립적일 수 있다.)

컴포넌트 ~ 단지 JSX를 반환하는 함수에 불과하다.
변경사항버튼, 취소버튼, 로그인버튼, 확인버튼 등
대부분 하나의 앱에는 모든 버튼이 통일된 모습을 가지고 있다.
우리가 만일 리액트 컴포넌트를 재활용할 방법을 모른다면
매 버튼마다 똑같은 코드를 여러번 작성해야한다.

만일 아래처럼 매번 대동소이한 컴포넌트를 만들지 말고
<div>
<saveBtn />
<confirmBtn />
</div>

공통 컴포넌트를 만든 뒤에, 원하는 부분만 수정할 순 없을까?
<div>
<Btn banana = "Save Changes" />
<Btn banana = "confirm"/>
</div>

<Btn banana = "Save Changes" />
는 
Btn({banana:"save Changes"}) 
와 똑같다.

ReactJS는 자동으로 네가 이곳에 넣은 모든 property(prop)들을 모조리 이 오브젝트 안에 집어넣는다.
오브젝트는 컴포넌트 함수의 첫번째 인자로 주어진다.


function Btn(props){
    return(
        <div> {props.banana}</div>
    )
}

props는 오브젝트기 때문에 우리는 {} 중괄호를 열어서 오브젝트로부터 banana를 받을 수 있다.

????????????????????????????????????????????????????
function Btn({banana}){
    return(
        <div> {banana}</div>
    )
}


///style 안에 있는 property 에서 삼항연산자 작성할 때 중괄호/괄호 작업 안해줘도 된다.
그냥 

    function Btn({banana, big}) {
        console.log(banana, big)
        return(
            <button
            style = {{
                backgroundColor : "tomato",
                color : "white",
                padding : "10px, 20px" ,
                border : 0 ,
                borderRadious : 10,
                fontSize : big ? 18 : 16,  ///삼항연산자 중괄호 없어도 돌아감
            }}
            >{banana}
            </button>
        );
    }

    function App() {
      return (
        <div>
            <Btn banana = "Save Button" big = {true} />
            <Btn banana = "confirm Button"/>
        </div>
      );
    }